# Config Language Translator

## Описание

Этот инструмент является транслятором для учебного конфигурационного языка, который преобразует входной текст в формате JSON в выходной текст на учебном конфигурационном языке. Он также поддерживает синтаксические ошибки с выдачей сообщений. Входной текст на языке JSON принимается из стандартного ввода, а выходной текст попадает в файл, путь к которому задается через команду.

### Особенности синтаксиса:

1. **Однострочные комментарии**:
    - Все строки, начинающиеся с `!`, считаются комментариями. Например:
      ```
      ! Это однострочный комментарий
      ```

2. **Массивы**:
    - Массивы в языке задаются с помощью квадратных скобок и разделяются пробелами:
      ```
      [ значение значение значение ... ]
      ```

3. **Словари**:
    - Словари представлены с использованием фигурных скобок и разделяются символом \`->\`:
      ```
      {
      имя -> значение.
      имя -> значение.
      имя -> значение.
      ...
      }
      ```

4. **Имена**:
    - Имена переменных должны начинаться с буквы или подчеркивания, а затем могут содержать буквы, цифры и подчеркивания:
      ```
      _a-zA-Z][_a-zA-Z0-9]*
      ```

5. **Значения**:
    - Значениями могут быть:
      - Числа.
      - Массивы.
      - Словари.

6. **Объявление константы на этапе трансляции**:
    - Константы объявляются с помощью ключевого слова \`const\`:
      ```
      const имя = значение;
      ```

7. **Вычисление константы на этапе трансляции**:
    - Для вычисления значений констант используется синтаксис:
      ```
      ?(имя)
      ```

## Формат входного файла

Входной файл должен быть в формате JSON. Пример структуры входного файла:

```json
{
  "constants": {
    "MAX_VALUE": 100,
    "PI": 3.14
  },
  "data": {
    "constant_example": "?(MAX_VALUE)"
  }
}
```

- **constants**: Объявление констант, которые могут быть использованы в данных.
- **data**: Пример использования констант с вычислением значений.

## Формат выходного файла

Выходной файл будет содержать преобразованные данные, используя синтаксис учебного конфигурационного языка. Пример выходного файла:

```text
constant_example -> ?(MAX_VALUE)
```

## Установка и сборка

1. Клонируйте репозиторий:
   ```bash
   git clone git@github.com:Dpanov2302/kisscm-3.git
   ```

2. Перейдите в каталог проекта:
   ```bash
   cd kisscm-3
   ```

3. Установите необходимые зависимости:
   ```bash
   pip install -r requirements.txt
   ```

## Использование

Для запуска программы используйте следующую команду:

```bash
python main.py <input_file> <output_file>
```

Где:
- `<input_file>` — путь к файлу с входными данными в формате JSON.
- `<output_file>` — путь к файлу, в который будет записан выходной конфигурационный текст.

### Пример:

```bash
python main.py IO/input.json IO/output.txt
```

## Тестирование

Для запуска тестов используйте фреймворк **unittest**. Тесты проверяют корректность парсинга, трансформации и обработки ошибок.

Для запуска тестов используйте следующую команду:

```bash
python -m unittest tests.py
```

### Пример:

```bash
python -m unittest tests.testParser
```

## Пример конфигурации

Вот пример входного JSON-файла и соответствующего выходного текста:

### Входной файл:

```json
{
  "constants": {
    "MAX_VALUE": 100,
    "PI": 3.14
  },
  "data": {
    "constant_example": "?(MAX_VALUE)",
    "list_example": [ "?(PI)", "?(MAX_VALUE)" ]
  }
}
```

### Выходной файл:

```text
constant_example -> 100
list_example -> [ 3.14, 100 ]
```

## Заключение

Этот проект позволяет преобразовать данные из JSON-формата в учебный конфигурационный язык с поддержкой вычислений и констант на этапе трансляции. Все конструкции языка (включая массивы, словари, константы) поддерживаются и покрыты тестами.
